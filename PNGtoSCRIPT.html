<!DOCTYPE html>
<html lang="en">
<head>
<title>PNG to SCRIPT</title>
<meta charset="utf-8">
<style>
body {
    background-color:#010101;
    color: #fff;
    margin: 0px;
    overflow: hidden;
    font-family: monospace;
}
#container{
	position:absolute;
	padding:0;
	height:100%;
	width: 100%;
	top:0;
	left:0;
	overflow: hidden;
}
#info{
	pointer-events:none;
	position:absolute;
	top:5px;
	left:5px;
	height:500px;
	width:500px;
}
</style>



</head>

<body>
<div id="container"></div>
<div id="info"></div>
<script type="text/javascript">

var head = document.getElementsByTagName('head')[0];
var info = document.getElementById('info');
var scripts = [];

var img = new Image();
img.onload = function() {
	var t01 = Date.now();
	var c=document.createElement("canvas"), r='', pix, i;
	c.width = c.height = this.width;
	c.getContext('2d').drawImage(this, 0, 0);
	var d = c.getContext('2d').getImageData(0, 0, c.width, c.height).data;
	var newScript = false;
	var ns = 0;
	var src = [];

	for ( i = 0, l=d.length; i<l; i+=4){
		pix = d[i];
		if(pix === 128) newScript = true;
		if( pix>31 && pix<128 ){ 
			if(newScript){ ns++; newScript = false; src[ns] ="";}
            src[ns] += String.fromCharCode(pix);
		}
	}
	var name, nn, pn, tmpsrc;
	for( i = 0; i<ns; i++){
		tmpsrc = src[i+1];
		src[i+1] = "";
		nn = tmpsrc.indexOf("var");
		pn = tmpsrc.indexOf("=");
		name = tmpsrc.substring(nn+4,pn);
		if(name === "={fromGeometry:function(n,t){var ") name = "TOOLS";
		if(name === "e") name = "TWEENLITE";
		info.innerHTML += name + ", ";
		scripts[i] = document.createElement("script");
		scripts[i].type = "text/javascript";
		scripts[i].name = name;
		scripts[i].id = name;
		scripts[i].charset = "utf-8";
		scripts[i].async = true;
		scripts[i].text = tmpsrc;

		head.appendChild(scripts[i])
	}

	tmpsrc = "";
	src = null;

	info.innerHTML += "<br>decode time: " + (Date.now()-t01) + " ms<br>";

	sourceLoaded();
};
img.src = "img/full.png";

//___________________________________________________________



// navigation var 
var camPos = { horizontal: 90, vertical: 75, distance: 1000, automove: false };
var mouse = { ox:0, oy:0, h:0, v:0, mx:0, my:0, down:false, over:false, moving:true };
var ToRad = Math.PI / 180;
var ToDeg = 180 / Math.PI;
// three var
var camera, scene, sceneSky, renderer, container, center, earth, clock, content;
var meshs = [];

//oimo var
var world, bodys = [], oimoMeshs = [], contentOimo;

function sourceLoaded() {
	clock = new THREE.Clock();

	renderer = new THREE.WebGLRenderer({precision: "mediump", antialias: false });
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.gammaInput = true;
	renderer.gammaOutput = true;
	renderer.setClearColor( 0x202020, 1 );
	renderer.shadowMapEnabled = true;
	renderer.shadowMapCullFace = THREE.CullFaceBack;
	renderer.autoClear = false;

	container = document.getElementById('container');
	container.appendChild( renderer.domElement );

	//

	camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 20000 );
    center = new THREE.Vector3(0,0,0);
    moveCamera();

	sceneSky = new THREE.Scene();
	scene = new THREE.Scene();


	var g = new THREE.SphereGeometry( 30, 30, 10 );
	var m = new THREE.MeshPhongMaterial( {});
	var g01 = new THREE.Mesh(g, m);





	//var ambientLight = new THREE.AmbientLight( 0x555a60 );
	//scene.add( ambientLight );

	var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 2 );
	hemiLight.color.setHex( 0xb6a385 );
	hemiLight.groundColor.setHex( 0x4b5054);
	hemiLight.position.set( 0, 100, 0 );
	scene.add( hemiLight );

	var pointLight = new THREE.PointLight( 0xc8ab81, 1, 1000 );
	pointLight.position.copy( Orbit(center,-90,120, 200));
	scene.add( pointLight );
	

	var spotLight = new THREE.SpotLight( 0xedeef0, 1 );
	spotLight.position.copy( Orbit(center,-90,180, 200));
	scene.add( spotLight );
	//spotLight.add(g01)


	var directionalLight = new THREE.DirectionalLight( 0xfffffd, 1.5 );
	directionalLight.position.copy( Orbit(center,-45,-45, 400));
	//directionalLight.position.set( 1, -0.5, 1 );
	//directionalLight.color.setHSL( 0.6, 1, 0.95 );
	scene.add( directionalLight );
	//directionalLight.position.multiplyScalar( 300 );

	directionalLight.castShadow = true;
	//directionalLight.shadowCameraVisible = true;

	directionalLight.shadowMapWidth = 1024;
	directionalLight.shadowMapHeight = 1024;

	directionalLight.shadowCameraNear = 200;
	directionalLight.shadowCameraFar = 600;

	directionalLight.shadowCameraLeft = -300;
	directionalLight.shadowCameraRight = 300;
	directionalLight.shadowCameraTop = 300;
	directionalLight.shadowCameraBottom = -300;

	directionalLight.shadowBias = -0.005;
	directionalLight.shadowDarkness = 0.6;

	var geometry = THREE.BufferGeometryUtils.fromGeometry( new THREE.SphereGeometry( 100, 60, 50 ));

	var mapHeight = THREE.ImageUtils.loadTexture( img.src );
	mapHeight.wrapS = mapHeight.wrapT = THREE.RepeatWrapping;
	mapHeight.anisotropy = renderer.getMaxAnisotropy();
	//mapHeight.repeat.set( 0.998, 0.998 );
	mapHeight.repeat.set( 1.998, 0.998 );
	mapHeight.offset.set( 0.001, 0.001 );
	mapHeight.format = THREE.RGBFormat;
	
	sky();		

	var material = new THREE.MeshPhongMaterial( { map: mapHeight, bumpMap: mapHeight, bumpScale: 3, metal: false,   color: 0x7fac2d, specular: 0xb0d551, shininess: 40, envMap:envSky, reflectivity:0.4, combine:THREE.MixOperation} );

	earth = new THREE.Mesh( geometry, material );
	scene.add( earth );
	earth.castShadow = true;
	earth.receiveShadow = true;

	content = new THREE.Object3D();
	scene.add( content );

	contentOimo = new THREE.Object3D();
	scene.add( contentOimo );

	

	// oimo init
    initSimulation();

    // particule init
    //initParticles();

	//

	window.addEventListener( 'resize', onWindowResize, false );
	container.addEventListener( 'mousemove', onMouseMove, false );
    container.addEventListener( 'mousedown', onMouseDown, false );
    container.addEventListener( 'mouseout', onMouseUp, false );
    container.addEventListener( 'mouseup', onMouseUp, false );
    container.addEventListener( 'mousewheel', onMouseWheel, false );
    container.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox
	animate();

	autoMove( 0, 60, 200);
	loadSea3DModel();
}

var envSky;

function sky() {
	var path = "img/skybox/";
	var format = '.jpg';
	var urls = [
			path + 'posx' + format, path + 'negx' + format,
			path + 'posy' + format, path + 'negy' + format,
			path + 'posz' + format, path + 'negz' + format
		];


	envSky = THREE.ImageUtils.loadTextureCube( urls );
	envSky.format = THREE.RGBFormat;

	// Skybox

	var shader = THREE.ShaderLib[ "cube" ];
	shader.uniforms[ "tCube" ].value = envSky;

	var material = new THREE.ShaderMaterial( {

		fragmentShader: shader.fragmentShader,
		vertexShader: shader.vertexShader,
		uniforms: shader.uniforms,
		side: THREE.BackSide

	} );

	var skyBox = new THREE.Mesh( new THREE.BoxGeometry( 10000, 10000, 10000 ), material );
	sceneSky.add( skyBox );

}

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );
}

function animate() {
	requestAnimationFrame( animate );
	delta = clock.getDelta();
	
	updateSimulation();

	updateParticules(delta);

	THREE.AnimationHandler.update( delta );

	renderer.render( sceneSky, camera );
	renderer.render( scene, camera );
}

// OIMO 

var initSimulation = function(){
	world = new OIMO.World();
	var ground = new OIMO.Body({size:[10000, 40, 10000], pos:[0,-20,0], world:world});

	var geo = THREE.BufferGeometryUtils.fromGeometry( new THREE.SphereGeometry( 2, 20, 20 ));
	var mat = new THREE.MeshPhongMaterial({ ambient: 0x202020, color: 0x202020, specular: 0x808080, shininess: 60 });

    var x, y, z;
	for(var i=0; i<100; i++){
		x = -100 + Math.random()*200;
        z = -100 + Math.random()*200;
        x = -10 + Math.random()*10;
        z = -10 + Math.random()*10;
        y = 600;
		bodys[i] = new OIMO.Body({type:'sphere', size:[2], pos:[x,y,z], move:true, world:world});
		oimoMeshs[i] = new THREE.Mesh( geo, mat );
		contentOimo.add(oimoMeshs[i]);
		oimoMeshs[i].castShadow = true;
	    oimoMeshs[i].receiveShadow = true;

	}

}

var updateSimulation = function(){
	world.step();
	var mtx = new THREE.Matrix4();
    var i = bodys.length;
    var m, mesh, py, px, len, x, y, z;

    while (i--){
    	m = bodys[i].body.getMatrix()
        mesh = oimoMeshs[i];
        if(m[15]===0){
        	mtx.fromArray(m);
        	mesh.rotation.setFromRotationMatrix( mtx );
        	x = m[12];
        	y = m[13];
        	z = m[14];
        	mesh.position.copy(latLongToVector3( x, z, 100, y) );
        }
    }
}

 

// SEA3D

var populateSea3D = function (){
	var geo = THREE.BufferGeometryUtils.fromGeometry(getSeaGeometry('Item000'));
	var geo2 = THREE.BufferGeometryUtils.fromGeometry(getSeaGeometry('Item007'));
	var mat1 = new THREE.MeshPhongMaterial({ ambient: 0x202020, color: 0x606060, specular: 0x505050, shininess: 60 });
	var mat2 = new THREE.MeshPhongMaterial({ ambient: 0x202020, color: 0x606060, specular: 0x505050, shininess: 60 });
    var mat3 = new THREE.MeshPhongMaterial({ ambient: 0x202020, color: 0x606060, specular: 0x505050, shininess: 60, skinning: true });

	//var hero = getSeaGeometry('monster_4_b5');//
	
	var h = getMeshByName("monster_4_b5");
//h.scale.set(0.2,0.2,-0.2);
	//console.log(h.animations[0].data.name)
	//THREE.AnimationHandler.add( h.animations[0].data );

	var hero = h.geometry;
	//hero.material = mat3;

	var i, rx, rz, m;
	for(i=0; i<50; i++){
		rx =  (Math.random()*360);
		rz =  (Math.random()*360);
		m = new THREE.Mesh(geo,  mat1);
		m.scale.set(0.4,0.4,0.4);
		m.rotation.z = -rx * ToRad;
		m.rotation.y = -rz * ToRad;

		m.position.copy( Orbit(center,rz,rx, 100));
		m.castShadow = m.receiveShadow = true;
		content.add(m);
	}
	for(i=0; i<50; i++){
		rx =  (Math.random()*360);
		rz =  (Math.random()*360);
		m = new THREE.Mesh(geo2,  mat2);
		m.scale.set(0.4,0.4,0.4);
		m.rotation.z = -rx * ToRad;
		m.rotation.y = -rz * ToRad;

		m.position.copy( Orbit(center,rz,rx, 100));
		m.castShadow = m.receiveShadow = true;
		content.add(m);
	}
	for(i=0; i<30; i++){
		rx =  (Math.random()*360);
		rz =  (Math.random()*360);
		//m = hero;
		m = new THREE.SkinnedMesh( hero, mat3, false );
		m.scale.set(0.4,0.4,-0.4);
		m.rotation.z = -rx * ToRad;
		m.rotation.y = -rz * ToRad;

		m.position.copy( Orbit(center,rz,rx, 110));
		m.castShadow = m.receiveShadow = true;

		var animation = new THREE.Animation( m, "monster_4_b5/root" );
		animation.play( 0.05 * Math.random() );
		content.add(m);
	}
}

var loadSea3DModel = function (){
	var SeaLoader = new THREE.SEA3D(true);
	SeaLoader.onComplete = function( e ) {
		for (var i=0; i !== SeaLoader.meshes.length; i++){
			meshs.push( SeaLoader.meshes[i] );
			//info.innerHTML += SeaLoader.meshes[i].name+"<br>";
		}
		populateSea3D();
	}
	SeaLoader.load( 'model/g.sea' );
}

var getSeaGeometry = function (name, scale, axe, child, deep){
	var c = child || 0;
	var d = deep || 0;
	var a = axe || "z";
	var s = scale || 1;
	var m; 
	if(c === 0 && d === 0) m = getMeshByName(name).geometry;
	else if(c >= 1 && d === 0) m = getMeshByName(name).children[c-1].geometry;
	else if(c >= 1 && d === 1) m = getMeshByName(name).children[0].children[c-1].geometry;
	else if(c >= 1 && d === 2) m = getMeshByName(name).children[0].children[0].children[c-1].geometry;
	scaleGeometry(m, s, a);
	return m;
}

var getMeshByName = function (name){
	for (var i=0; i !== meshs.length; i++){
		if(meshs[i].name === name){
			return meshs[i];
		} 
	} 
}

var scaleGeometry = function (geometry, scale, Axe) {
	var s = 1;
	var axe = Axe || 'z' 
	for( var i = 0; i < geometry.vertices.length; i++) {
		var vertex	= geometry.vertices[i];
		if(axe==='x')vertex.x *= -s;
		else vertex.x *= s;
		if(axe==='y')vertex.y *= -s;
		else vertex.y *= s;
		if(axe==='z')vertex.z *= -s;
		else vertex.z *= s;
	}
	geometry.computeFaceNormals();
	geometry.computeCentroids();
	geometry.computeVertexNormals();
	geometry.verticesNeedUpdate = true;
}

// PARTICULES
var particleGroup;

function initParticles() {
	particleGroup = new SPE.Group({
		texture: THREE.ImageUtils.loadTexture('img/smokeparticle.png'),
		maxAge: 2
	});

	var emitter = new SPE.Emitter({
		position: new THREE.Vector3(0, 100, 0),
        positionSpread: new THREE.Vector3( 0, 0, 0 ),

		acceleration: new THREE.Vector3(0, -10, 0),
		accelerationSpread: new THREE.Vector3( 10, 0, 10 ),

		velocity: new THREE.Vector3(0, 10, 0),
		velocitySpread: new THREE.Vector3(60, 30, 60),

		colorStart: new THREE.Color('white'),
		colorEnd: new THREE.Color('black'),

		sizeStart: 10,
		sizeEnd: 30,

		particleCount: 100
	});

	particleGroup.addEmitter( emitter );
	scene.add( particleGroup.mesh );

}

var updateParticules = function(delta){
	if(particleGroup) particleGroup.tick( delta );
}

// MATH

var Orbit = function (origine, horizontal, vertical, distance) {
    var p = new THREE.Vector3();
    var phi = vertical*ToRad;
    var theta = horizontal*ToRad;
    p.x = (distance * Math.sin(phi) * Math.cos(theta)) + origine.x;
    p.z = (distance * Math.sin(phi) * Math.sin(theta)) + origine.z;
    p.y = (distance * Math.cos(phi)) + origine.y;
    return p;
}

function latLongToVector3(lat, lon, radius, heigth) {
	var p = new THREE.Vector3();
    var phi = (lat)*ToRad;
    var theta = (lon)*ToRad;
    p.x = (radius+heigth) * Math.cos(phi) * Math.cos(theta);
    p.y = (radius+heigth) * Math.sin(phi) * Math.cos(theta);
    p.z = (radius+heigth) * Math.sin(theta);
    /*
    p.x = -(radius+heigth) * Math.cos(phi) * Math.cos(theta);
    p.y = (radius+heigth) * Math.sin(phi);
    p.z = (radius+heigth) * Math.cos(phi) * Math.sin(theta);*/
    return p;
}

// MOUSE & NAVIGATION

var autoMove = function (h, v, d) {
	TweenLite.to(camPos, 3, {horizontal: h, vertical: v, distance: d, onUpdate: moveCamera });
}

var moveCamera = function () {
    camera.position.copy(Orbit(center, camPos.horizontal, camPos.vertical, camPos.distance));
    camera.lookAt(center);
}

var onMouseDown = function (e) {
    e.preventDefault();
    mouse.ox = e.clientX;
    mouse.oy = e.clientY;
    mouse.h = camPos.horizontal;
    mouse.v = camPos.vertical;
    mouse.down = true;
}

var onMouseUp = function (e) {
    mouse.down = false;
    document.body.style.cursor = 'auto';
}

var onMouseMove = function (e) {
    e.preventDefault();
    if (mouse.down ) {
        document.body.style.cursor = 'move';
        camPos.horizontal = ((e.clientX - mouse.ox) * 0.3) + mouse.h;
        camPos.vertical = (-(e.clientY - mouse.oy) * 0.3) + mouse.v;
        moveCamera();
    }
}

var onMouseWheel = function (e) {
    var delta = 0;
    if(e.wheelDeltaY){delta=e.wheelDeltaY*0.01;}
    else if(e.wheelDelta){delta=e.wheelDelta*0.05;}
    else if(e.detail){delta=-e.detail*1.0;}
    camPos.distance-=(delta*10);
    moveCamera();   
}

</script>
</body>
</html>
