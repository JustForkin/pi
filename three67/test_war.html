<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Boids War - js do it</title>
<meta name="Description" content="" />
<meta name="Keywords"  content="" />
<style>
    * {  margin: 0; padding: 0; border: 0;}
    body { background-color: #adaaa6; overflow: hidden; color:#202125; font-family:Verdana; font-size: 12px; }
    input{ margin:0; padding:4px; }
    #interface{ position: absolute; left:0px; top:90px; width:0px; height:0px; }
    #info{ pointer-events:none; position: absolute; left:10px; top:10px; width: 400px; height: 400px; }
    #logo{ pointer-events:none; position: absolute; left:-10px; bottom:-10px; width: 300px; height: 150px; }
</style>

<script src="build/three.min.js"></script>
<script src="build/sea3d.min.js"></script>
<script src="build/war.min.js"></script>
<!--<script src="src/war/War.js"></script>-->
<script src="js/Detector.js"></script>
<script src="js/BufferGeometryUtils.js"></script>
<script src="js/miniGUI.js"></script>

</head>
<body>
<div id='container'></div>
<div id="info"></div>
<div id='interface'></div>

<!--++++++++++++++++++++++++++++++++-->
<!--           WAR WORKER           -->
<!--++++++++++++++++++++++++++++++++-->

<script id="workerWar" type="javascript/worker">
var simulator = null;
var perf = "";
var ToRad = Math.PI / 180;
var peace = false;


self.onmessage = function(e) {

    var warMatrixs = e.data.warMatrixs;
    var warMouse = e.data.warMouse;
    var maxBoids;
    var deadPool = [];
   // var warMouse = e.data.warMouse;
    var t = 0;

    if ( simulator == null && e.data.url !== "") { // init
        // Load war script
        importScripts(e.data.url);
        maxBoids = 0;
        simulator = new WAR.Simulator(e.data.People || 30);
        simulator.resize(3600, 2700)
        simulator.init();

    } else { // loop
    	if(e.data.isPeace!==peace){
    		peace = e.data.isPeace;
    		simulator.setPeace(peace);
    	}
    	simulator.deadPool.length = 0;
    	simulator.setMouse(warMouse[0], warMouse[1]);
    	if(e.data.click){simulator.add(warMouse[0], warMouse[1]);}
    	

    	t = Date.now();
        simulator.loop();
        
        //var clock = 0.001 * (Date.now() - e.data.oldTime);
        deadPool = simulator.deadPool;
        maxBoids = simulator.boids.length;

        var i = maxBoids;
        var p;
        while(i--){
        	p = simulator.boids[i];

            warMatrixs[(4*i) + 0 ] = p.x;
            warMatrixs[(4*i) + 1 ] = p.y;
            warMatrixs[(4*i) + 2 ] = p.r;
            warMatrixs[(4*i) + 3 ] = p.type.id;
        }

        perf = "";//simulator.performance.fpsint;
       
    }
    //oldTime = Date.now();
    self.postMessage({ perf:perf, oldTime:t, maxBoids:maxBoids, deadPool:deadPool, warMatrixs:warMatrixs }, [warMatrixs.buffer]);

}
</script>

<!--++++++++++++++++++++++++++++++++-->
<!--          MAIN SCRIPT           -->
<!--++++++++++++++++++++++++++++++++-->

<script>
var q0 = new THREE.Quaternion();
var q1 = new THREE.Quaternion();
var q2 = new THREE.Quaternion();
var v = new THREE.Vector3();
var ToRad = Math.PI / 180;
var warMatrixs = new Float32Array(1000*4);
var oldTime = 0;
var dtwar = 1/60;
var isPeace = false;
var warSendTime;
var warDeadPool;
var warMouse = [0,0,0];
var workerWar = new Worker(window.URL.createObjectURL(new Blob([document.querySelector('#workerWar').textContent], {type : 'text/javascript'}) ));
workerWar.postMessage = workerWar.webkitPostMessage || workerWar.postMessage;

workerWar.onmessage = function(e) {
    // Get fresh data from the worker
    warMatrixs = e.data.warMatrixs;
    warDeadPool = e.data.deadPool;
    // remove dead
    var i = warDeadPool.length;
    while(i--){
    	removeP(warDeadPool[i]);
    }

    i = e.data.maxBoids;
    var x, y, m;
    while(i--){
    	if(!meshs[i])addP(i, warMatrixs[(4*i) + 3]);
    	else{
    		m = meshs[i];
    		x = -(45+22.5)+(warMatrixs[(4*i) + 1]/10)*0.5;
    		y = (warMatrixs[(4*i) + 0]/10);
    		m.position.copy(latLongToVector3( x,y, PlaneteSize ) );
    		//q0 = new THREE.Quaternion();
            q1.setFromAxisAngle(new THREE.Vector3(0,1,0), warMatrixs[4*i + 2]+(90*ToRad) );
            q2.setFromAxisAngle(new THREE.Vector3(1,0,0), 90*ToRad );
            q0.multiplyQuaternions(q2, q1);
            m.children[0].quaternion.slerp(q0,0.1);
    		//m.children[0].rotation.y=warMatrixs[(4*i) + 2];
    		m.lookAt(v);
    		//m.rotation.z = -y * ToRad;
		    //m.rotation.y = -x * ToRad;
    	}
    }

    sourceInfo ="Polulation:"+e.data.maxBoids+"<br>";// e.data.perf;
	var delay = (1000 / 60)- (Date.now()-warSendTime);//dtwar * 1000 - (Date.now()-warSendTime);
    //if(delay < 0) delay = 0;

    //oldTime = e.data.oldTime;
    setTimeout(sendDataToWarWorker, delay);
}

function sendDataToWarWorker(url){
    warSendTime = Date.now();
    workerWar.postMessage({ People:People, url: url || "", click:mouse.click, warMouse:warMouse, isPeace:isPeace, warMatrixs:warMatrixs },[warMatrixs.buffer]);
    mouse.click = false;
}


// ---------------------------------------------------------

var info = document.getElementById("info");
var menu = document.getElementById("interface");

// THREE var
var container, camera, scene, renderer, cam, mouse, key, clock, pool, content, projector, raycaster, marker;
var vsize = { x:window.innerWidth, y:window.innerHeight, z:window.innerWidth/window.innerHeight };
var fps = [0,0,0,0];
var ToRad = Math.PI / 180;
var bgcolor = 0xadaaa6;
var meshs = [];
var planete;
var axeY, axeZ;
var sourceInfo = "";

var sim;
window.onload = init;

var People = 60;
var PlaneteSize = 5;
var PeopleSize = 0.2;

var pgeo, pmat=[];

function init() {
	init3D();
	initWorkerSimulator();
	//initSimulator();
}

function init3D() {
    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

    var g= new miniGUI.OnOff ({ container:menu, value:isPeace, y:0,name:"Peace", onChange: function(value){ isPeace = value; } });

    cam = { horizontal: 120, vertical: 80, distance: 30, automove: false };
    mouse = { ox:0, oy:0, h:0, v:0, mx:0, my:0, down:false, click:false, over:false, moving:true };
    key = [0,0,0,0,0,0,0,0];

    clock = new THREE.Clock();

    renderer = new THREE.WebGLRenderer( {precision: "lowp", antialias: false } );
    renderer.setSize( vsize.x, vsize.y );
    renderer.setClearColor( bgcolor, 1 );

    container = document.getElementById("container");
    container.appendChild( renderer.domElement );

    renderer.gammaInput = true;
    renderer.gammaOutput = true;
    renderer.shadowMapCullFace = THREE.CullFaceBack;
    renderer.shadowMapEnabled = true;
    renderer.autoClearColor = false;
    renderer.autoClear = false;

    // scene
    scene = new THREE.Scene();

    // camera
    camera = new THREE.PerspectiveCamera( 30, vsize.z, 0.5, 1000 );
    center = new THREE.Vector3(0,0,0);
    moveCamera();

    scene.add( camera );

    projector = new THREE.Projector();
	raycaster = new THREE.Raycaster();

	content =new THREE.Object3D();
	scene.add(content);

    var light, materials;
    scene.add( new THREE.AmbientLight( bgcolor ) );

    light = new THREE.DirectionalLight( 0xffffff, 1 );
    var d = 10;

    light.position.set( d, d, d );

    light.castShadow = true;
    //light.shadowCameraVisible = true;

    light.shadowMapWidth = 1024;
    light.shadowMapHeight = 1024;

    light.shadowCameraLeft = -d;
    light.shadowCameraRight = d;
    light.shadowCameraTop = d;
    light.shadowCameraBottom = -d;

    light.shadowCameraFar = 3*d;
    light.shadowCameraNear = d;
    light.shadowDarkness = 0.25;
    light.shadowBias =  -0.002;

    scene.add( light );

    var backMat = new THREE.MeshBasicMaterial( { color: bgcolor, side:THREE.BackSide, depthWrite: false } );
    var backGeo = new THREE.Mesh( new THREE.SphereGeometry( 500, 6, 6 ), backMat );
    scene.add( backGeo );

    // PLANETE
    var planeteMat = new THREE.MeshPhongMaterial( { ambient:bgcolor, specular: 0x505050, shininess: 60, color:0x555555, transparent:true, opacity:0.9 } );
    planete = new THREE.Mesh( new THREE.SphereGeometry( PlaneteSize, 30, 20 ), planeteMat );
    content.add( planete );
    planete.castShadow = true;
    planete.receiveShadow = true;

    var topgeo = new THREE.CylinderGeometry( PlaneteSize*0.38,PlaneteSize*0.38,PlaneteSize*0.1, 20, 1 )
    var top = new THREE.Mesh( topgeo, planeteMat );
    top.position.y = PlaneteSize-((PlaneteSize*0.1)*0.5);
    scene.add( top );
    top.castShadow = true;
    top.receiveShadow = true;
    var bottom = new THREE.Mesh( topgeo, planeteMat );
    bottom.position.y = -PlaneteSize+((PlaneteSize*0.1)*0.5);
    scene.add( bottom );
    bottom.castShadow = true;
    bottom.receiveShadow = true;

    // AXIS
    /*var ayMat = new THREE.MeshBasicMaterial( {color:0xFF5555} );
    var aygeo = new THREE.BoxGeometry( 0.01, 0.01, PlaneteSize );
    aygeo.applyMatrix( new THREE.Matrix4().makeTranslation( 0,0,-PlaneteSize*0.5 ) )
    axeY = new THREE.Mesh( aygeo, ayMat );
    var azMat = new THREE.MeshBasicMaterial( {color:0x55FF55} );
    var azgeo = new THREE.BoxGeometry( 0.01, 0.01, PlaneteSize );
    azgeo.applyMatrix( new THREE.Matrix4().makeTranslation( 0,0,-PlaneteSize*0.5 ) )
    axeZ = new THREE.Mesh( azgeo, azMat );
    scene.add( axeY );
    axeY.add( axeZ );*/

    // MATKER
    var geometry = new THREE.CylinderGeometry( 0, 0.15, 0.5, 3 );
	geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0.25, 0 ) );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( Math.PI / 2 ) );
	marker = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0xffffff } ) );
	scene.add(marker);
	marker.castShadow = true;
    marker.receiveShadow = true;


    // TMP PEOPLE
    pmat[0] = new THREE.MeshPhongMaterial( {  ambient:bgcolor, specular: 0x505050, shininess: 60, color:0xFF8811 } );
    pmat[1] = new THREE.MeshPhongMaterial( {  ambient:bgcolor, specular: 0x505050, shininess: 60, color:0x11FF11 } );
    pmat[2] = new THREE.MeshPhongMaterial( {  ambient:bgcolor, specular: 0x505050, shininess: 60, color:0x1111FF } );
    pmat[3] = new THREE.MeshPhongMaterial( {  ambient:bgcolor, specular: 0x505050, shininess: 60, color:0xFF11FF } );
    //pgeo = new THREE.SphereGeometry( PeopleSize, 6, 6 );
    //pgeo = new THREE.BoxGeometry( PeopleSize/4, PeopleSize/2, PeopleSize );
    //pgeo.applyMatrix( new THREE.Matrix4().makeTranslation( 0,0,-PeopleSize*0.5 ) )

    pgeo = new THREE.BoxGeometry( PeopleSize/2, PeopleSize, PeopleSize/4 );
    pgeo.applyMatrix( new THREE.Matrix4().makeTranslation( 0,-PeopleSize*0.5,0 ) )

    
    

    // load sea3d model
    //pool = new SEA3D.Pool('res/model/droid.sea', populate);

    // events
    var body = document.body;
    window.addEventListener( 'resize', resize, false );
    container.addEventListener( 'mousemove', onMouseMove, false );
    //container.addEventListener( 'mouseclick', onMouseClick, false );
    container.addEventListener( 'mousedown', onMouseDown, false );
    container.addEventListener( 'mouseout', onMouseUp, false );
    container.addEventListener( 'mouseup', onMouseUp, false );
    if( body.addEventListener ){
        body.addEventListener( 'mousewheel', onMouseWheel, false ); //chrome
        body.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox
    }else if( body.attachEvent ){
        body.attachEvent("onmousewheel" , onMouseWheel); // ie
    }

    loop();
}

function resize() {
    vsize = { x:window.innerWidth, y:window.innerHeight, z:window.innerWidth/window.innerHeight };
	camera.aspect = vsize.z;
	camera.updateProjectionMatrix();
	renderer.setSize( vsize.x, vsize.y );
}

function loop() {
    requestAnimationFrame( loop, renderer.domElement );
    renderer.render( scene, camera );
    displayInfo();
}

function displayInfo(){
    fps[2] = Date.now();
    if (fps[2]-1000>fps[1]){ fps[1]=fps[2]; fps[3]=fps[0]; fps[0]=0; } fps[0]++;

    var txtinfo =[
        "<h3>BOID WAR</h3><br>",
        sourceInfo,
        "Three: " + fps[3] +" fps<br>",
        //"Mouse x:"+warMouse[0].toFixed(0) +" y:"+warMouse[1].toFixed(0)
    ].join("\n");
    info.innerHTML = txtinfo;
}

//_____________

function addP(i, n) {
	var mesh = new THREE.Object3D();
	var child = new THREE.Mesh( pgeo, pmat[n] );
	child.castShadow = true;
    child.receiveShadow = true;
    mesh.add(child);
    scene.add( mesh );
    mesh.children[0].rotation.x = 90*ToRad;
	meshs[i] = mesh;
}

function removeP(i) {
	meshs[i].remove( meshs[i].children[0]);
	scene.remove( meshs[i]);
	meshs.splice(i, 1);
}

//-----------------------------------
// MATH
//-----------------------------------

function rayTest(sh) {
	if ( content.children.length > 0 ) {
		var vector = new THREE.Vector3( mouse.mx, mouse.my, 1 );
		projector.unprojectVector( vector, camera );
		raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
		var intersects = raycaster.intersectObjects( content.children );
		if ( intersects.length > 0 ) {
			marker.position.set( 0, 0, 0 );
			marker.lookAt(intersects[0].face.normal);
			marker.position.copy( intersects[0].point );

			var p = intersects[0].point.clone();
			var rX = (360-getElementAngle(0,0, p.x, p.z));
			var l = Math.sqrt( p.x * p.x + p.z * p.z )
			var rY = ((270)+getElementAngle(0,0, l, p.y))

			if(axeY && axeZ){
				axeY.rotation.y = rX*ToRad;
			    axeZ.rotation.x = rY*ToRad;
			}

			var px = (360-(rX))-90;
			if(px<0)px = 360+px
			var py = (270/2)+((rY-270-90)*2);

			warMouse = [px*10,py*10, 0];

	    }
	} else {
		warMouse = [-9999,-9999, 0];
	}
}

function getElementAngle(x1, y1, x2, y2) {
	var adj = x2 - x1;
	var opp = y2 - y1;	
	var angle = Math.abs(Math.atan(opp/adj) * 180/Math.PI);
	if (adj > 0 && opp < 0 ) angle = 90 - angle;
	else if (adj >= 0 && opp >= 0) angle += 90;
	else if (adj < 0 && opp >= 0) angle = 180 + (90 - angle);
	else angle += 270;
	return angle;
}

function latLongToVector3(Lat, Lon, radius) {
	var p = new THREE.Vector3();
    var phi = (Lat)*ToRad;
    var theta = (Lon)*ToRad;
    p.x = radius * Math.cos(phi) * Math.cos(theta);
    p.y = radius * Math.sin(phi);
    p.z = radius * Math.cos(phi)* Math.sin(theta);
    return p;
}

function Orbit(origine, horizontal, vertical, distance) {
    var p = new THREE.Vector3();
    var phi = vertical*ToRad;
    var theta = horizontal*ToRad;
    p.x = (distance * Math.sin(phi) * Math.cos(theta)) + origine.x;
    p.z = (distance * Math.sin(phi) * Math.sin(theta)) + origine.z;
    p.y = (distance * Math.cos(phi)) + origine.y;
    return p;
}

//-----------------------------------
// MOUSE & NAVIGATION 
//-----------------------------------

function moveCamera() {
    camera.position.copy(Orbit(center, cam.horizontal, cam.vertical, cam.distance));
    camera.lookAt(center);
}

function onMouseDown(e) {
    e.preventDefault();
    mouse.mx = ( e.clientX / vsize.x ) * 2 - 1;
	mouse.my = - ( e.clientY / vsize.y ) * 2 + 1;
    mouse.ox = e.clientX;
    mouse.oy = e.clientY;
    mouse.h = cam.horizontal;
    mouse.v = cam.vertical;
    mouse.down = true;
    mouse.click = true;

    rayTest(true);
}

function onMouseUp(e) {
    mouse.down = false;
    document.body.style.cursor = 'auto';
}

function onMouseMove(e) {
    e.preventDefault();
    if ( mouse.down ) {
        document.body.style.cursor = 'move';
        cam.horizontal = ((e.clientX - mouse.ox) * 0.3) + mouse.h;
        cam.vertical = (-(e.clientY - mouse.oy) * 0.3) + mouse.v;    
        moveCamera();
    }else{
    	mouse.mx = ( e.clientX / vsize.x ) * 2 - 1;
	    mouse.my = - ( e.clientY / vsize.y ) * 2 + 1;
	    rayTest(false);
	}
}

function onMouseWheel(e) {
    e.preventDefault();
    var delta = 0;
    if(e.wheelDelta){delta=e.wheelDelta*-1;}
    else if(e.detail){delta=e.detail*20;}
    cam.distance+=(delta/80);
    if(cam.distance<0.01)cam.distance = 0.01;
    if(cam.distance>150)cam.distance = 150;
    moveCamera(); 
}

//_______________________________________________

function initWorkerSimulator() {
	sendDataToWarWorker(document.location.href.replace(/\/[^/]*$/,"/") + "build/war.min.js");
}

//________________________________________________

function initSimulator() {

    sim = new WAR.Simulator(People);
    sim.resize(3600, 2700);
    sim.init()

    //document.addEventListener('keydown', keyDown, false);

    setInterval(loopSim, 1000 / 60);
}

function resizeSim() {
    sim.resize( window.innerWidth,  window.innerWidth);
}

function mouseMove(e) {
    sim.setMouse(e.clientX, e.clientY);
}

function mouseOut(e) {
    sim.setMouse(-9999, -9999);
}

function click(e) {
    sim.add(e.clientX, e.clientY);
}

function keyDown(e) {
    if (e.keyCode === 71) sim.removeKiller();// g key
    if (e.keyCode === 80) sim.peace();// p key
    if (e.keyCode === 68) sim.debug();// d key
}

function loopSim(){
	sim.setMouse(warMouse[0], warMouse[1]);
	if(mouse.click){sim.add(warMouse[0], warMouse[1]); }
   	



    sim.loop();
    var p;
    // remove dead
    var i = sim.deadPool.length;
    while(i--){
    	removeP(sim.deadPool[i]);
    }
    sim.deadPool.length = 0;

    i = sim.boids.length;
    while(i--){
    	p = sim.boids[i];
    	if(!meshs[i])addP(i, p.type.id);
    	else{
    		meshs[i].position.copy(latLongToVector3( -(45+22.5)+(p.y/10)*0.5, (p.x/10), PlaneteSize, 0.1) );
    	}

    }
    mouse.click = false;

}

</script>
</body>
</html>
