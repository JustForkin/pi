<!DOCTYPE html>
<html lang="en">
<head>
    <title>Assets lab 2</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
    * {  margin: 0; padding: 0; border: 0;}
    body { background-color: #383838; overflow: hidden; color: #eeeeee; font-family: monospace; font-size: 12px; }
    input{ margin:0; padding:4px; height:30px;}
    #interface{ position: absolute; left:0px; top:90px; width:0px; height:0px; }
    #info{ pointer-events:none; position: absolute; left:10px; top:15px; width: 140px; height: 120px; }
</style>

<script src="build/three.min.js"></script>
<script src="build/sea3d.min.js"></script>
<script src="js/Detector.js"></script>
<script src="js/BufferGeometryUtils.js"></script>
<script src="js/miniGUI.js"></script>
</head>
<body>
<div id='container'></div>
<div id="info"></div>
<div id='interface'></div>

<!--++++++++++++++++++++++++++++++++-->
<!--          OIMO WORKER           -->
<!--++++++++++++++++++++++++++++++++-->

<script id="workerOimo" type="javascript/worker">    
/*var world = null;
var timestep = 1/60;
var perf = "";
var body = [];

self.onmessage = function(e) {
    var ToRad = Math.PI / 180;
    var matrixs = e.data.matrixs;
    var rvoVel = e.data.rvoVel;
    var N = e.data.N;

    if ( world == null && e.data.url !== "") {
        // Load oimo script
        importScripts(e.data.url);
        
        // Init physics
        OIMO.WORLD_SCALE = 1;
        OIMO.INV_SCALE = 1;
        world = new OIMO.World(e.data.dt, 2, 8);
        world.gravity.init(0,-10,0);

        // Ground plane
        var ground = new OIMO.Body({size:[140.8, 10, 70.4], pos:[0,-5,0], world:world, config:[0, 0.3, 0.1]});

        // wall
        var w1 = new OIMO.Body({size:[140.8, 20, 3.2], pos:[0,10,36.8], world:world, config:[0, 0.3, 0.1]});
        var w2 = new OIMO.Body({size:[140.8, 20, 3.2], pos:[0,10,-36.8], world:world, config:[0, 0.3, 0.1]});
        var w3 = new OIMO.Body({size:[3.2, 20, 76.8], pos:[72,10,0], world:world, config:[0, 0.3, 0.1]});
        var w4 = new OIMO.Body({size:[3.2, 20, 76.8], pos:[-72,10,0], world:world, config:[0, 0.3, 0.1]});

        var vx, vy, rx, ry, r;
        for(var i=0; i!==N; i++){
            if(i >= N*0.5) {
                vx =-10+Math.random()*20;
                vy =-10+Math.random()*20;
                body[i] = new OIMO.Body({type:'sphere', size:[0.5], pos:[vx, 0.5,vy], move:true, world:world, config:[1, 0.1, 0.7]});
            }else{
                vx = (Math.cos(i * 2 * Math.PI /( N*0.5)))*30;
                vy = (Math.sin(i * 2 * Math.PI /( N*0.5)))*30;
                r = Math.atan2(vx, vy);

                //body[i] = new OIMO.Body({type:'box', size:[0.5,  1,  0.5], pos:[vx,0.51,vy], rot:[0, r*(180 / Math.PI),0], move:true, noSleep:true, world:world, config:[10, 0.3, 0.1]});
                body[i] = new OIMO.Body({type:'box', size:[0.5,  2,  0.5], pos:[vx,1,vy], rot:[0, r*(180 / Math.PI),0], move:true, noSleep:true, world:world, config:[10, 0.3, 0.1]});
            } 
        }
    } else { // loop

        world.step();

        var i = N;
        var m, j, b;

        while(i--){
            j = 16;
            if(body[i]){
            b = body[i].body;
            m = b.getMatrix();
            while(j--){
                matrixs[(16*i) + j] = m[j];
            } 
            if(i < N*0.5){

                b.linearVelocity.x = rvoVel[(i*3)+0]/timestep;
                b.linearVelocity.z = rvoVel[(i*3)+1]/timestep;

                b.angularVelocity.y = rvoVel[(i*3)+2]/timestep;

                b.orientation.x = 0;
                // b.orientation.y = 1;
                b.orientation.z = 0;
                //b.orientation.s = rvoVel[(i*3)+2]/timestep;

                //b.orientation.normalize(b.orientation);
            }  
        }
    }

    perf = world.performance.fpsint;

    }
    // Send data back to the main thread
    self.postMessage({ perf:perf, matrixs:matrixs }, [matrixs.buffer]);
};*/
</script>

<!--++++++++++++++++++++++++++++++++-->
<!--         MAIN SCRIPT            -->
<!--++++++++++++++++++++++++++++++++-->

<script>

// Parameters
var ToRad = Math.PI / 180;
var info = document.getElementById("info");
var menu = document.getElementById("interface");
var sourceInfo = "";

// THREE var
var container, camera, scene, renderer, cam, mouse, key, clock, pool;
var fps = [0,0,0,0];

var bgcolor = 0x606060;
var meshs = [];
var squel = [];
var isSkeletonVisible = false;
var myModel;
var nloop = 0;

window.onload = init;

//OIMO worker var
/*var dt = 1/60, N=200;
var matrixs = new Float32Array(N*16);
var workerOimo = new Worker(window.URL.createObjectURL( new Blob([document.querySelector('#workerOimo').textContent], {type:'text/javascript'}) ));
workerOimo.postMessage = workerOimo.webkitPostMessage || workerOimo.postMessage;
var oimoSendTime; // time when we sent last message
var oimoInfo = 0; // fps info 
var oimoMeshes=[];



//-----------------------------------
//
//   OIMO WORKER 
//
//-----------------------------------

workerOimo.onmessage = function(e) {
    // Get fresh data from the worker
    matrixs = e.data.matrixs;
    i = N;
    while(i--){
        var m = [];
        var mtx = new THREE.Matrix4();
        j = 16;
        while(j--) m[j] = matrixs[16*i + j];
        mtx.fromArray( m );
        oimoMeshes[i].position.setFromMatrixPosition( mtx )
        oimoMeshes[i].rotation.setFromRotationMatrix( mtx );
    }

    var delay = dt * 1000 - (Date.now()-oimoSendTime);
    if(delay < 0) delay = 0;

    oimoInfo = e.data.perf;
    
    setTimeout(sendDataToOimoWorker, delay);
}

function sendDataToOimoWorker(url){
    oimoSendTime = Date.now();
    workerOimo.postMessage({ N: N, dt: dt, url: url || "", key:key, matrixs: matrixs },[matrixs.buffer]);
}

function initOimoWorker (){
    sendDataToOimoWorker(document.location.href.replace(/\/[^/]*$/,"/") + "build/oimo.min.js");
}
*/
//-----------------------------------
//
//   THREE JS SIDE 
//
//-----------------------------------

function init() {
    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

    var bar = new miniGUI.Slide ({ container:menu, value:0, y:40, name:"DoorMorph",
            onChange: function(value){ if(myModel) myModel.setWeightByName("droid001", value); }
        });

    var bar2 = new miniGUI.OnOff ({ container:menu, value:isSkeletonVisible, y:10,name:"Skeleton", onChange: function(value){ toogleSkeleton(value) } });


    cam = { horizontal: 120, vertical: 80, distance: 30, automove: false };
    mouse = { ox:0, oy:0, h:0, v:0, mx:0, my:0, down:false, over:false, moving:true };
    key = [0,0,0,0,0,0,0,0];

    clock = new THREE.Clock();


    renderer = new THREE.WebGLRenderer( {precision: "lowp", antialias: false } );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setClearColor( bgcolor, 1 );

    container = document.getElementById("container");
    container.appendChild( renderer.domElement );

    

    //renderer.gammaInput = true;
    //renderer.gammaOutput = true;
    renderer.shadowMapEnabled = true;
    renderer.autoClearColor = false;
    renderer.autoClear = false;

    // scene
    scene = new THREE.Scene();

    // camera
    camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 0.5, 1000 );
    center = new THREE.Vector3(0,3,0);
    moveCamera();

    scene.add( camera );

    // lights
    var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 1 );
    hemiLight.color.setHex( 0xb6a385 );
    hemiLight.groundColor.setHex( 0x4b5054);
    hemiLight.position.set( 0, 100, 0 );
    scene.add( hemiLight );

    var light, materials;
    scene.add( new THREE.AmbientLight( bgcolor ) );

    light = new THREE.DirectionalLight( 0xffffff, 1.3 );
    var d = 30;

    light.position.set( d, d, d );

    light.castShadow = true;
    //light.shadowCameraVisible = true;

    light.shadowMapWidth = 1024;
    light.shadowMapHeight = 1024;

    light.shadowCameraLeft = -d;
    light.shadowCameraRight = d;
    light.shadowCameraTop = d;
    light.shadowCameraBottom = -d;

    light.shadowCameraFar = 3*d;
    light.shadowCameraNear = d;
    light.shadowDarkness = 0.5;

    scene.add( light );

    var backMat = new THREE.MeshBasicMaterial( { color: bgcolor, side:THREE.BackSide, depthWrite: false } );
    var backGeo = new THREE.Mesh( new THREE.SphereGeometry( 500, 6, 6 ), backMat );
    scene.add( backGeo );

    var material = new THREE.MeshBasicMaterial( { color: bgcolor } );

    geometry = THREE.BufferGeometryUtils.fromGeometry( new THREE.PlaneGeometry( 400, 400, 1, 1 ) );
    
    var mesh = new THREE.Mesh( geometry, material );
    mesh.castShadow = false;
    mesh.receiveShadow = true;
    mesh.rotation.x = -90 * ToRad;
    scene.add( mesh );

    // load sea3d model
    pool = new SEA3D.Pool('res/model/droid.sea', populate);

    // events
    var body = document.body;
    window.addEventListener( 'resize', resize, false );
    window.addEventListener( 'keydown', onKeyDown, false );
    window.addEventListener( 'keyup', onKeyUp, false );
    container.addEventListener( 'mousemove', onMouseMove, false );
    container.addEventListener( 'mousedown', onMouseDown, false );
    container.addEventListener( 'mouseout', onMouseUp, false );
    container.addEventListener( 'mouseup', onMouseUp, false );
    if( body.addEventListener ){
        body.addEventListener( 'mousewheel', onMouseWheel, false ); //chrome
        body.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox
    }else if( body.attachEvent ){
        body.attachEvent("onmousewheel" , onMouseWheel); // ie
    }

    loop();
}

function resize() {
    renderer.setSize( window.innerWidth, window.innerHeight );
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
}

function loop() {
    requestAnimationFrame( loop );
    var delta = clock.getDelta();
    nloop++
    if(nloop===2){
        nloop = 0;
        THREE.AnimationHandler.update( delta*2 );
        if(squel.length && isSkeletonVisible){
        for(var i=0, j=squel.length; i<j; i++){
            squel[i].update()
        }
    }
    }
    renderer.render( scene, camera );
    displayInfo()
}

function displayInfo(){
    fps[2] = Date.now();
    if (fps[2]-1000>fps[1]){ fps[1]=fps[2]; fps[3]=fps[0]; fps[0]=0; } fps[0]++;

    var txtinfo =[
        "<h3>DROID LAB</h3><br>",
        sourceInfo,
        //"Oimo Physics: " + oimoInfo +" fps<br>",
        "Three Render: " + fps[3] +" fps"
    ].join("\n");
    info.innerHTML = txtinfo;
}

//--------------------------------
// SEA3D
//--------------------------------

function toogleSkeleton(value){
    for(var i=0, j=squel.length; i<j; i++){
        squel[i].visible = value;
    }
}

function populate(){
    var dTexture = THREE.ImageUtils.loadTexture( 'res/texture/droid.jpg' );
    dTexture.wrapS = dTexture.wrapT = THREE.RepeatWrapping;
    dTexture.anisotropy = renderer.getMaxAnisotropy();
    dTexture.repeat.set( 1,-1);

    var mat = new THREE.MeshPhongMaterial({ ambient: 0x202020, map: dTexture, specular: 0x505050, shininess: 60, skinning: true, morphTargets: true });

    var model = pool.getGeometry("droid");


    console.log(pool.models[0].anim);
    console.log(pool.models[0].morph);
    //console.log(Pool.models[0].name);

    var i, rx, rz, m, w, s;

    var nnn, anim, rand, bone;
    var num = 1;

    var skeletonHelper;
    

    for(i=0; i<num; i++){
        rand = Math.floor(Math.random()*5);
        rx =  -10+(Math.random()*20);
        rz =  -10+(Math.random()*20);
        s = 0.05

        m = new THREE.SkinnedMesh(model, mat, false );
        m.scale.set(s,s,-s);

        skeletonHelper = new THREE.SkeletonHelper( m );
        skeletonHelper.material.linewidth = 3;
        m.add( skeletonHelper );
        squel[i] = skeletonHelper;
        squel[i].visible = isSkeletonVisible;

        //m.rotation.y = (Math.random()*360) * ToRad;

        /*m.position.x = -rx;
        if(rand!==4)m.position.y = 5.5;
        else m.position.y = 1;
        m.position.z = -rz;*/

        //m.position.copy( Orbit(center,rz,rx, 105));
        m.castShadow = true;//
        m.receiveShadow = true;
        //nnn = 1//Math.round(Math.random()*2);
        //if(nnn>0){ anim = "droid/idle";}
        //else { }

        anim = "droid/walk";
        myModel = m;

        //m.setWeightByName("droid001", 1);

        var animation = new THREE.Animation( m, anim );
        animation.play( 10 * Math.random() );
        scene.add(m);  
    }
}

//-----------------------------------
// MATH
//-----------------------------------

function Orbit(origine, horizontal, vertical, distance) {
    var p = new THREE.Vector3();
    var phi = vertical*ToRad;
    var theta = horizontal*ToRad;
    p.x = (distance * Math.sin(phi) * Math.cos(theta)) + origine.x;
    p.z = (distance * Math.sin(phi) * Math.sin(theta)) + origine.z;
    p.y = (distance * Math.cos(phi)) + origine.y;
    return p;
}

//-----------------------------------
// MOUSE & NAVIGATION 
//-----------------------------------

function moveCamera() {
    camera.position.copy(Orbit(center, cam.horizontal, cam.vertical, cam.distance));
    camera.lookAt(center);
}

function onMouseDown(e) {
    e.preventDefault();
    mouse.ox = e.clientX;
    mouse.oy = e.clientY;
    mouse.h = cam.horizontal;
    mouse.v = cam.vertical;
    mouse.down = true;
}

function onMouseUp(e) {
    mouse.down = false;
    document.body.style.cursor = 'auto';
}

function onMouseMove(e) {
    e.preventDefault();
    if (mouse.down ) {
        document.body.style.cursor = 'move';
        cam.horizontal = ((e.clientX - mouse.ox) * 0.3) + mouse.h;
        cam.vertical = (-(e.clientY - mouse.oy) * 0.3) + mouse.v;
        moveCamera();
    }
}

function onMouseWheel(e) {
    e.preventDefault();
    var delta = 0;
    if(e.wheelDelta){delta=e.wheelDelta*-1;}
    else if(e.detail){delta=e.detail*20;}
    cam.distance+=(delta/80);
    if(cam.distance<0.01)cam.distance = 0.01;
    if(cam.distance>150)cam.distance = 150;
    moveCamera(); 
}

//-----------------------------------
// KEYBOARD 
//-----------------------------------

function onKeyDown( e ) {
    switch ( e.keyCode ) {
        case 38:case 87:case 90: key[0]=1; break; // up, W, Z
        case 40:case 83:         key[1]=1; break; // down, S
        case 37:case 65:case 81: key[2]=1; break; // left, A, Q
        case 39:case 68:         key[3]=1; break; // right, D
        case 17:case 67:         key[4]=1; break; // ctrl, c
        case 32:                 key[5]=1; break; // space
        case 96:case 48:  key[6]=0; break; //0
        case 97:case 49:  key[6]=1; break; //1
        case 98:case 50:  key[6]=2; break; //2
        case 99:case 51:  key[6]=3; break; //3
        case 100:case 52: key[6]=4; break; //4
        case 101:case 53: key[6]=5; break; //5
        case 102:case 54: key[6]=6; break; //6
        case 103:case 55: key[6]=7; break; //7
        case 104:case 56: key[6]=8; break; //8
        case 105:case 57: key[6]=9; break; //9
    }
    //KEY(key);
}

function onKeyUp( e ) {
    switch( e.keyCode ) {
        case 38:case 87:case 90: key[0]=0; break; // up, W, Z
        case 40:case 83:         key[1]=0; break; // down, S
        case 37:case 65:case 81: key[2]=0; break; // left, A, Q
        case 39:case 68:         key[3]=0; break; // right, D
        case 17:case 67:         key[4]=0; break; // ctrl, c
        case 32:                 key[5]=0; break; // space
    }
    //KEY(key);
}

</script>
</body>
</html>